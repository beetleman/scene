(ns scene.db
  (:require [mount.core :refer [defstate]]
            [clojure.core.async
             :as a
             :refer [put! >! <! chan sliding-buffer close! alts! timeout]]
            [scene.utils :as utils]
            [scene.config :as config])
  (:require-macros [cljs.core.async.macros :refer [go-loop]]))

(def redis (js/require "redis"))

(defstate conn
  :start (.createClient redis config/redis-url)
  :stop (.quit @conn))


(defn redis-key
  "produce key with prefix"
  [s]
  (str config/key-prefix ":" s))

(defn log-address-key
  "produce redis key for given `log` map, based on contract address"
  [log]
  (->> log
       :address
       (str "address:")
       redis-key))

(defn log-topic-key
  "produce redis jey for given `log` map, based on topic"
  [log]
  (->> log
       :topics
       first
       (str "topic:")
       redis-key))

(defn save-log
  "save `log` in db in key generated by `key-fn`"
  [log key-fn]
  (let [ch (chan)]
    (.hmset @conn
            (key-fn log)
            (:blockNumber log)
            (utils/clj->json log)
            (utils/callback-chan-fn ch))
    ch))

(defn parse-event [[address raw-event]]
  {:blockNumber address
   :event       (utils/json->clj raw-event)})

(defn get-log
  "get log by `key` (any key) and return"
  [key]
  (let [ch (chan)]
    (.hgetall @conn (redis-key key) (utils/callback-chan-fn ch))
    ch))
